// upload-doc.js — patched to handle json.imagePath / filename / fullPath fallbacks
(() => {
  const $ = id => document.getElementById(id);
  const step1 = $('step1'), step2 = $('step2'), step3 = $('step3');
  const customerIdEl = $('customerId'), termOtherEl = $('termOther'), termsBox = $('termsBox');
  const toStep2Btn = $('toStep2');
  const docInput = $('docInput');
  const stage = $('stage'), displayCanvas = $('displayCanvas'), sigBoxEl = $('sigBox'), sigPad = $('sigPad');
  const zoomInBtn = $('zoomIn'), zoomOutBtn = $('zoomOut'), resetViewBtn = $('resetView'), lockAndSignBtn = $('lockAndSign');
  const previewImg = $('previewImg'), backToSignBtn = $('backToSign'), saveBtn = $('saveBtn'), statusEl = $('status');
  const saveMessage = $('saveMessage');
  const EXPORT_SCALE = 3; // change to 3 if you want higher resolution

  // terms
  const TERMS = ['PAN','Peri','FI','Núcleo','Coroa','Inicial','Final','PIX','ONF'];
  function renderTerms(){
    termsBox.innerHTML = '';
    TERMS.forEach(t=>{
      const lab = document.createElement('label'); lab.className='chip';
      lab.innerHTML = `<input type="checkbox" value="${t}"/> <span>${t}</span>`;
      termsBox.appendChild(lab);
    });
  }
  renderTerms();

  // state
  let customerId = '';
  let termsState = new Set();
  let imgBitmap = null;     // Image element used for drawing
  let fullCanvas = null;    // full-res canvas (image native size)
  let fCtx = null;
  let uploadedPdfFilename = null; // store uploaded PDF filename returned by convert-pdf
  let penThickness = 2; // default 1..3 (maps to pixel widths)
  const dCtx = displayCanvas.getContext('2d');

  // display transform state
  let stageW=0, stageH=0;
  let scale=1, offsetX=0, offsetY=0, minScale=0.2, maxScale=6;
  let pointers = new Map();
  let lastX=0, lastY=0, isPanning=false;

  // signature rect (display coords)
  const sigRect = { x:0, y:0, w:0, h:0 };

  // final image data (dataURL)
  let finalImageData = null;

  function showStep(n){
    step1.classList.toggle('hidden', n!==1);
    step2.classList.toggle('hidden', n!==2);
    step3.classList.toggle('hidden', n!==3);
  }
  showStep(1);

  toStep2Btn.addEventListener('click', () => {
    const cid = (customerIdEl.value||'').trim();
    if(!/^\d{1,8}$/.test(cid)){ alert('Informe o ID do cliente (1 a 8 dígitos)'); return; }
    customerId = cid;
    termsState = new Set(Array.from(document.querySelectorAll('#termsBox input:checked')).map(i=>i.value));
    if(termOtherEl.value.trim()) termsState.add(termOtherEl.value.trim());
    showStep(2);
    setTimeout(resizeStage, 60);
  });

  function resizeStage(){
    const rect = stage.getBoundingClientRect();
    stageW = Math.max(320, Math.floor(rect.width));
    stageH = Math.max(360, Math.floor(rect.width * 0.64));
    displayCanvas.width = stageW;
    displayCanvas.height = stageH;

    sigRect.w = Math.floor(stageW * 0.9);
    sigRect.h = Math.floor(stageH * 0.39);
    sigRect.x = Math.floor((stageW - sigRect.w)/2);
    sigRect.y = Math.floor(stageH - sigRect.h - 16);

    sigBoxEl.style.left = sigRect.x + 'px';
    sigBoxEl.style.top = sigRect.y + 'px';
    sigBoxEl.style.width = sigRect.w + 'px';
    sigBoxEl.style.height = sigRect.h + 'px';

    sigPad.style.left = sigRect.x + 'px';
    sigPad.style.top = sigRect.y + 'px';
    sigPad.style.width = sigRect.w + 'px';
    sigPad.style.height = sigRect.h + 'px';
    sigPad.width = sigRect.w;
    sigPad.height = sigRect.h;
    sigPad.classList.add('hidden');
    sigPad.style.pointerEvents = 'none';

    redraw();
  }
  window.addEventListener('resize', resizeStage);

  function redraw(){
    dCtx.clearRect(0,0,stageW,stageH);
    if(!imgBitmap) return;
    dCtx.save();
    dCtx.setTransform(scale,0,0,scale,offsetX,offsetY);
    dCtx.drawImage(imgBitmap, 0, 0);
    dCtx.restore();
  }

  function fitToStage(){
    if(!imgBitmap) return;
    const s = Math.min(stageW / imgBitmap.naturalWidth, stageH / imgBitmap.naturalHeight);
    scale = s;
    offsetX = Math.floor((stageW - imgBitmap.naturalWidth*scale)/2);
    offsetY = Math.floor((stageH - imgBitmap.naturalHeight*scale)/2);
    minScale = s*0.35;
    maxScale = s*6;
    redraw();
  }

  // robust loader: accepts absolute web path or filesystem-like fullPath / filename returned by server
  function buildPreviewUrlFromServerResp(json){
    if(!json) return null;
    // prefer web-accessible imagePath
    if(json.imagePath) return (json.imagePath.startsWith('/') ? window.location.origin + json.imagePath : json.imagePath);
    // if server returned fullPath (filesystem), attempt to map to /uploads/<cid>/<filename>
    if(json.fullPath && typeof json.fullPath === 'string'){
      // try to extract filename
      const fn = json.filename || json.fullPath.split(/[\\/]/).pop();
      if(fn && customerId) return `${window.location.origin}/uploads/${encodeURIComponent(customerId)}/${encodeURIComponent(fn)}`;
    }
    // fallback: if only filename present
    if(json.filename && customerId) return `${window.location.origin}/uploads/${encodeURIComponent(customerId)}/${encodeURIComponent(json.filename)}`;
    return null;
  }

  function loadImageFromUrl(url){
  if(!url){ alert('No preview URL provided by server'); statusEl.textContent = 'No preview URL'; return; }
  // absolute or relative starting with '/'
  const absUrl = (url && url.startsWith('/')) ? (window.location.origin + url) : url;
  statusEl.textContent = 'Fetching preview...';
  fetch(absUrl, { method: 'GET' })
    .then(resp => {
      if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
      return resp.blob();
    })
    .then(blob => {
      const objectUrl = URL.createObjectURL(blob);
      const img = new Image();
      // Important: allow cross-origin blob usage
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        imgBitmap = img;

        // Create a high-resolution fullCanvas for exporting (EXPORT_SCALE times image native pixels)
        fullCanvas = document.createElement('canvas');
        fullCanvas.width = Math.max(1, Math.round(img.naturalWidth * EXPORT_SCALE));
        fullCanvas.height = Math.max(1, Math.round(img.naturalHeight * EXPORT_SCALE));
        fCtx = fullCanvas.getContext('2d');

        // Clear and draw the image scaled to the fullCanvas size (this produces the high-res base)
        fCtx.clearRect(0, 0, fullCanvas.width, fullCanvas.height);
        // Draw scaled so fullCanvas contains high-res image pixels
        fCtx.drawImage(img, 0, 0, fullCanvas.width, fullCanvas.height);

        // Note: we keep imgBitmap as the unscaled Image for display + pan/zoom calculations.
        // fitToStage uses imgBitmap.naturalWidth/naturalHeight as before.
        fitToStage();
        URL.revokeObjectURL(objectUrl);
        statusEl.textContent = 'File loaded. Adjust and sign.';
      };
      img.onerror = (e) => {
        console.error('img load error', e);
        alert('Error loading image for alignment. Check server logs and ensure the converted file exists and is accessible.');
        statusEl.textContent = 'Error loading image';
      };
      img.src = objectUrl;
    })
    .catch(err => {
      console.error('Failed to fetch preview image:', err);
      alert('Failed to fetch preview image: ' + err.message + '\nCheck convert-pdf response and server logs.');
      statusEl.textContent = 'Failed to fetch preview';
    });
}

  docInput.addEventListener('change', async (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    statusEl.textContent = 'Loading file...';
    if(f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf')){
      try {
        const fd = new FormData();
        fd.append('customerId', customerId);
        fd.append('terms', Array.from(termsState).join('-'));
        fd.append('doc', f);
        statusEl.textContent = 'Converting PDF on server...';
        const res = await fetch('/convert-pdf', { method: 'POST', body: fd });
        const json = await res.json();
        if(!json.success) throw new Error(json.error || 'Conversion failed');
        // Build a usable preview URL from server response (handles imagePath, fullPath, filename)
        const previewUrl = buildPreviewUrlFromServerResp(json);
        if(!previewUrl) throw new Error('Server returned no usable preview URL');
        loadImageFromUrl(previewUrl);
        uploadedPdfFilename = json.uploadedFilename || null; // store for later save cleanup
        statusEl.textContent = 'PDF converted. Adjust and sign.';
      } catch(err){
        console.error(err);
        alert('PDF conversion failed: ' + err.message);
        statusEl.textContent = 'PDF conversion failed';
      }
    } else {
      const url = URL.createObjectURL(f);
      loadImageFromUrl(url);
      statusEl.textContent = 'Image loaded. Adjust and sign.';
    }
    setTimeout(resizeStage, 80);
  });

  // pointer handlers (unchanged)
  displayCanvas.addEventListener('pointerdown', e => {
    displayCanvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if(pointers.size === 1){ isPanning = true; lastX = e.clientX; lastY = e.clientY; }
  });
  displayCanvas.addEventListener('pointermove', e => {
    if(!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if(pointers.size === 1 && isPanning){
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      offsetX += dx; offsetY += dy; redraw();
    } else if(pointers.size === 2){
      const pts = Array.from(pointers.values());
      const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      if(!displayCanvas._lastD){ displayCanvas._lastD = d; return; }
      const diff = d - displayCanvas._lastD;
      const zoomFactor = 1 + diff/300;
      applyZoom(zoomFactor, stageW/2, stageH/2);
      displayCanvas._lastD = d;
    }
  });
  displayCanvas.addEventListener('pointerup', e => {
    displayCanvas.releasePointerCapture(e.pointerId);
    pointers.delete(e.pointerId);
    if(pointers.size < 2) displayCanvas._lastD = null;
    if(pointers.size === 0) isPanning = false;
  });
  displayCanvas.addEventListener('pointercancel', ()=>{ pointers.clear(); isPanning=false; displayCanvas._lastD=null; });

  displayCanvas.addEventListener('wheel', e => { e.preventDefault(); const factor = e.deltaY < 0 ? 1.08 : 0.92; const rect = displayCanvas.getBoundingClientRect(); applyZoom(factor, e.clientX - rect.left, e.clientY - rect.top); }, { passive:false });

  function applyZoom(factor, cx, cy){
    const newScale = Math.max(minScale, Math.min(maxScale, scale * factor));
    const k = newScale / scale;
    offsetX = cx - k * (cx - offsetX);
    offsetY = cy - k * (cy - offsetY);
    scale = newScale;
    redraw();
  }
  zoomInBtn.addEventListener('click', ()=> applyZoom(1.12, stageW/2, stageH/2));
  zoomOutBtn.addEventListener('click', ()=> applyZoom(0.9, stageW/2, stageH/2));
  resetViewBtn.addEventListener('click', ()=> {
  fitToStage();
  // clear signature pad as well
  if (sigPad && sigPad.getContext) {
    const ctx = sigPad.getContext('2d');
    ctx.clearRect(0,0,sigPad.width,sigPad.height);
  }
});

  // Pen thickness buttons (match IDs used in HTML snippet)
  const penThinBtn = document.getElementById('penThin');
  const penMedBtn = document.getElementById('penMed');
  const penThickBtn = document.getElementById('penThick');

  function applyPenStyle() {
    if (!sigCtx) return;
    // Map penThickness 1..3 to a reasonable pixel width adjusted by device pixel ratio
    const dpr = window.devicePixelRatio || 1;
    let px;
    if (penThickness === 1) px = 2;
    else if (penThickness === 2) px = 4;
    else px = 6;
    sigCtx.lineWidth = Math.max(1, px);
    sigCtx.lineCap = 'round';
    sigCtx.lineJoin = 'round';
  }

  if (penThinBtn) penThinBtn.addEventListener('click', () => { penThickness = 1; applyPenStyle(); });
  if (penMedBtn) penMedBtn.addEventListener('click', () => { penThickness = 2; applyPenStyle(); });
  if (penThickBtn) penThickBtn.addEventListener('click', () => { penThickness = 3; applyPenStyle(); });

// Convert display (screen) coordinates back into image pixel coordinates
// px, py = top-left corner of something in display space
  function displayToImage(px, py) {
    return {
    x: (px - offsetX) / scale,
    y: (py - offsetY) / scale
  };
}


  // signature overlay (unchanged)
  let signingEnabled = false;
  let sigCtx = null;
  function enableSignaturePad(){
    sigPad.classList.remove('hidden');
    sigPad.style.pointerEvents = 'auto';
    signingEnabled = true;
    const rect = sigPad.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    sigPad.width = rect.width * dpr; sigPad.height = rect.height * dpr;
    sigPad.style.width = rect.width + 'px'; sigPad.style.height = rect.height + 'px';
    sigCtx = sigPad.getContext('2d');
    sigCtx.setTransform(dpr,0,0,dpr,0,0);
    sigCtx.clearRect(0,0,sigPad.width,sigPad.height);
    sigCtx.strokeStyle = '#000';
    applyPenStyle();
    let drawing = false;
    function start(e){ drawing=true; const p = pos(e); sigCtx.beginPath(); sigCtx.moveTo(p.x,p.y); e.preventDefault(); }
    function move(e){ if(!drawing) return; const p=pos(e); sigCtx.lineTo(p.x,p.y); sigCtx.stroke(); e.preventDefault(); }
    function end(e){ drawing=false; e.preventDefault(); }
    function pos(e){ const r = sigPad.getBoundingClientRect(); if(e.touches) { return { x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top }; } return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    sigPad.addEventListener('pointerdown', start);
    sigPad.addEventListener('pointermove', move);
    window.addEventListener('pointerup', end);
  }
  function disableSignaturePad(){
    sigPad.classList.add('hidden');
    sigPad.style.pointerEvents = 'none';
    signingEnabled = false;
  }

  lockAndSignBtn.addEventListener('click', () => {
    if(!imgBitmap){ alert('Selecione um documento primeiro.'); return; }
    enableSignaturePad();
    lockAndSignBtn.classList.add('hidden');
    const pv = document.createElement('button'); pv.className='btn'; pv.id='toPreview'; pv.textContent='Pré-visualizar';
    pv.addEventListener('click', buildPreview);
    lockAndSignBtn.parentNode.appendChild(pv);
    statusEl.textContent = 'Assine dentro da área tracejada.';
  });

  function buildPreview(){
  if(!fullCanvas || !fCtx){ alert('Documento não carregado.'); return; }

  // Redraw the high-res base image onto the fullCanvas (in case it's been recreated)
  // If loadImageFromUrl already drew it, this is harmless.
  fCtx.clearRect(0, 0, fullCanvas.width, fullCanvas.height);
  // Draw the base image scaled to fullCanvas size
  fCtx.drawImage(imgBitmap, 0, 0, fullCanvas.width, fullCanvas.height);

  // Convert signature canvas to an image
  const sigDataUrl = sigPad.toDataURL('image/png');
  const sigImg = new Image();
  sigImg.onload = () => {
    // Compute signature position in image coordinates (original image px)
    const topLeft = displayToImage(sigRect.x, sigRect.y); // returns image-coordinate (px) relative to original image size
    const boxWImg = sigRect.w / scale;
    const boxHImg = sigRect.h / scale;

    // Because fullCanvas was created at EXPORT_SCALE times original image pixels,
    // multiply image coords by EXPORT_SCALE when drawing onto fullCanvas
    const sx = Math.round(topLeft.x * EXPORT_SCALE);
    const sy = Math.round(topLeft.y * EXPORT_SCALE);
    const sw = Math.round(boxWImg * EXPORT_SCALE);
    const sh = Math.round(boxHImg * EXPORT_SCALE);

    // Draw the signature image scaled to the correct size on fullCanvas
    fCtx.drawImage(sigImg, sx, sy, sw, sh);

    // Now produce the final JPG from the high-res fullCanvas
    const jpg = fullCanvas.toDataURL('image/jpeg', 0.92);
    previewImg.src = jpg;
    finalImageData = jpg;
    showStep(3);
    statusEl.textContent = 'Pré-visualização pronta';
  };
  sigImg.onerror = (e) => {
    console.error('Signature image load error', e);
    alert('Erro ao processar assinatura');
  };
  sigImg.src = sigDataUrl;
}

  backToSignBtn.addEventListener('click', ()=> {
    showStep(2);
    statusEl.textContent = '';
  });

  // Save flow -> send finalImageData (base64) to /save-doc as JSON (server expects this)
  saveBtn.addEventListener('click', async () => {
    if (!finalImageData) { alert('Nada para salvar'); return; }
    const selectedTerms = Array.from(termsState);
    const payload = {
      customerId,
      fileName: null, // server will generate filename according to rule
      imageData: finalImageData,
      terms: selectedTerms.join('-'),
      originalUploadedFilename: uploadedPdfFilename || null	
    };


    statusEl.textContent = 'Salvando...';
    try {
      const resp = await fetch('/save-doc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const text = await resp.text();
      let j;
      try {
        j = JSON.parse(text);
      } catch (e) {
        throw new Error('Server returned non-JSON: ' + text.slice(0, 400));
      }

      if (!j.success) throw new Error(j.error || 'Save failed');

      // Build display path to show to the user
      let displayPath = j.path || j.fullPath || '';

      if (!displayPath && j.filename && customerId) {
        displayPath = `${window.location.origin}/uploads/${encodeURIComponent(customerId)}/${encodeURIComponent(j.filename)}`;
      }

      saveMessage.textContent = `✅ Saved: ${j.filename || '(no filename)'} — Path: ${displayPath}`;
      statusEl.textContent = 'Saved';
      alert(`Saved successfully\nFile: ${j.filename || '(no filename)'}\nPath: ${displayPath}`);

      if (confirm('Adicionar outro documento?')) {
        const keepCid = customerId;
        resetAll();
        customerIdEl.value = keepCid;
        showStep(1);
      } else {
        window.location.href = './index.html';
      }
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Save failed';
      alert('Error saving document: ' + err.message);
    }
  });

  function resetAll() {
    docInput.value = '';
    imgBitmap = null; fullCanvas = null; fCtx = null; finalImageData = null;
    sigPad.getContext('2d').clearRect(0, 0, sigPad.width, sigPad.height);
    disableSignaturePad();
    $('toPreview')?.remove();
    lockAndSignBtn.classList.remove('hidden');
    previewImg.src = '';
    saveMessage.textContent = '';
    statusEl.textContent = '';
  }

  // initial
  setTimeout(()=>{ resizeStage(); showStep(1); }, 100);

})();
